# Step 2: ARRANGE - Dependencies & Chapters

## Dependency Map

```
Level 0: THE PARTNERSHIP
    │
    ├── You + AI collaborate
    ├── AI writes code, you direct
    └── Prompt is the bridge
            │
            ▼
Level 1: HOW IT WORKS
    │
    ├── AI sees only what you show
    ├── Iteration is normal
    └── First result is a draft
            │
            ▼
Level 2: WHAT YOU DO
    │
    ├── Six operations (CREATE, READ, EDIT, RUN, FIX, EXTEND)
    ├── Breaking down problems
    └── Being specific
            │
            ▼
Level 3: DOING IT WELL
    │
    ├── Giving good feedback
    ├── Providing context
    └── Refine vs restart
            │
            ▼
Level 4: HANDLING PROBLEMS
    │
    ├── Error types
    ├── Debugging
    └── Testing
            │
            ▼
Level 5: BUILDING THINGS
    │
    ├── Incremental building
    └── Patterns (pipeline, web, automation, API)
            │
            ▼
Level 6: DOMAIN APPLICATION
    │
    └── Engineering calculations
            │
            ▼
Level 7: COMPLETE PROJECT
    │
    └── Idea → Working software
```

---

## Chapter Structure

### PART 1: FOUNDATIONS

**Chapter 1: The Partnership**
- You and AI are partners
- What you bring (problem, context, intent, judgment)
- What AI brings (code, patterns, syntax, libraries)
- The prompt connects both sides
- Neither works alone, together = anything

**Chapter 2: The Reality**
- AI sees only what you show it
- First result is a draft
- Iteration is normal (3-5 cycles simple, 5-15 complex)
- This is the process, not failure

**Chapter 3: The Actions**
- CREATE: make new things
- READ: understand things
- EDIT: change things
- RUN: execute things
- FIX: repair things
- EXTEND: add to things
- (Every prompt is one of these six)

---

### PART 2: SKILLS

**Chapter 4: Breaking Down**
- Big problems → small pieces
- Each piece = one prompt
- If you need "and" to describe it, split it
- The one-sentence test

**Chapter 5: Being Specific**
- Vague in → vague out
- Specific in → specific out
- What, where, how, why, example
- The specificity spectrum

**Chapter 6: Giving Feedback**
- Good feedback vs bad feedback
- The formula: "Got X, expected Y, change Z"
- Include error messages
- Describe expected vs actual

**Chapter 7: Context**
- What AI cannot see
- What to share
- Constraints, preferences, history
- More context = better output

**Chapter 8: Refine or Restart**
- When to keep refining
- When to start fresh
- The 5-attempt rule
- Recognizing wrong approaches

---

### PART 3: PROBLEMS

**Chapter 9: Error Types**
- Syntax errors (code invalid)
- Runtime errors (fails when running)
- Logic errors (wrong output, no error)
- Import errors (missing stuff)
- Data errors (bad data)

**Chapter 10: Debugging**
- Error message is your friend
- Paste full error
- Describe what you tried
- Describe what you expected
- Isolation technique

**Chapter 11: Testing**
- Input → Code → Output → Compare
- Arrange, Act, Assert
- Normal cases
- Edge cases
- Error cases

---

### PART 4: BUILDING

**Chapter 12: Incremental Building**
- Small verified steps
- Build, test, extend, test
- Never add to broken code
- Fix first, then extend

**Chapter 13: Data Pipeline**
- Input → Clean → Process → Output
- Validate before processing
- Transform to useful format

**Chapter 14: Web App**
- Frontend (what user sees)
- Backend (logic + data)
- Build bottom-up
- Single file for simple tools

**Chapter 15: Automation**
- Trigger → Action → Output
- Types: time, file, event, manual
- Build action first, add trigger later

**Chapter 16: API**
- Request → Process → Response
- CRUD operations
- One endpoint at a time

---

### PART 5: APPLICATION

**Chapter 17: Engineering Calculations**
- Input → Validate → Calculate → Check → Output
- Units always
- Limits always
- Material properties
- Formatted reports

**Chapter 18: Complete Project**
- Define → Break down → Build → Test → Refine → Use
- Everything together
- Real example walkthrough

---

## Summary

| Part | Chapters | Focus |
|------|----------|-------|
| 1. Foundations | 1-3 | Mental models |
| 2. Skills | 4-8 | How to prompt well |
| 3. Problems | 9-11 | Handling errors |
| 4. Building | 12-16 | Patterns & construction |
| 5. Application | 17-18 | Domain & capstone |

**Total: 18 chapters**

---

## Teaching Order Rationale

1. **Partnership first** - Must understand collaboration before anything else
2. **Reality second** - Set expectations about iteration
3. **Actions third** - The vocabulary of what you can do
4. **Skills next** - How to do those actions well
5. **Problems then** - What goes wrong and how to fix
6. **Building after** - Patterns for construction
7. **Application last** - Put it all together

Each level requires the previous. No skipping.

---

**Next:** Step 3 - SPLIT (identify drawings per chapter)
